<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CholeskyDecomposer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-algebra</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.algebra</a> &gt; <span class="el_source">CholeskyDecomposer.java</span></div><h1>CholeskyDecomposer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.algebra;

/**
 * This class allows decomposition of matrices using Cholesky decomposition,
 * which consists on retrieving a lower or upper triangular matrix so that input
 * matrix can be decomposed as: A = L * L' = R' * R, where A is provided input
 * matrix, L is a lower triangular matrix and R is an upper triangular matrix.
 * Note: Cholesky decomposition can only be correctly computed on positive
 * definite matrices.
 */
public class CholeskyDecomposer extends Decomposer {

    /**
     * Internal storage of Cholesky decomposition for provided input matrix.
     */
    private Matrix r;

    /**
     * Boolean indicating whether provided input matrix is symmetric and
     * positive definite.
     */
    private boolean spd;

    /**
     * Constructor of this class.
     */
    public CholeskyDecomposer() {
<span class="fc" id="L43">        super();</span>
<span class="fc" id="L44">        r = null;</span>
<span class="fc" id="L45">        spd = false;</span>
<span class="fc" id="L46">    }</span>

    /**
     * Constructor of this class.
     *
     * @param inputMatrix Reference to input matrix to be decomposed.
     */
    public CholeskyDecomposer(final Matrix inputMatrix) {
<span class="fc" id="L54">        super(inputMatrix);</span>
<span class="fc" id="L55">        r = null;</span>
<span class="fc" id="L56">        spd = false;</span>
<span class="fc" id="L57">    }</span>

    /**
     * Returns decomposer type corresponding to Cholesky decomposition.
     *
     * @return Decomposer type.
     */
    @Override
    public DecomposerType getDecomposerType() {
<span class="fc" id="L66">        return DecomposerType.CHOLESKY_DECOMPOSITION;</span>
    }

    /**
     * Sets reference to input matrix to be decomposed.
     *
     * @param inputMatrix Reference to input matrix to be decomposed.
     * @throws LockedException Exception thrown if attempting to call this
     *                         method while this instance remains locked.
     */
    @Override
    public void setInputMatrix(final Matrix inputMatrix) throws LockedException {
<span class="fc" id="L78">        super.setInputMatrix(inputMatrix);</span>
<span class="fc" id="L79">        r = null;</span>
<span class="fc" id="L80">        spd = false;</span>
<span class="fc" id="L81">    }</span>


    /**
     * Returns boolean indicating whether decomposition has been computed and
     * results can be retrieved.
     * Attempting to retrieve decomposition results when not available, will
     * probably raise a NotAvailableException.
     *
     * @return Boolean indicating whether decomposition has been computed and
     * results can be retrieved.
     */
    @Override
    public boolean isDecompositionAvailable() {
<span class="fc bfc" id="L95" title="All 2 branches covered.">        return r != null;</span>
    }

    /**
     * This method computes Cholesky matrix decomposition, which consists on
     * factoring provided input matrix whenever it is square, symmetric and
     * positive definite into a lower triangulator factor such that it follows
     * next expression: A = L * L'
     * where A is input matrix and L is lower triangular factor (L' is its
     * transposed).
     * Cholesky decomposition can also be computed using Right Cholesky
     * decomposition, in which case A = R' * R, where R is an upper triangular
     * factor equal to L'.
     * Both factors L and R will be accessible once Cholesky decomposition has
     * been computed.
     * Note: During execution of this method, this instance will remain locked,
     * and hence attempting to set some parameters might raise a LockedException
     * Note: After execution of this method, Cholesky decomposition will be
     * available and operations such as retrieving L matrix factor or solving
     * systems of linear equations will be able to be done. Attempting to call
     * any of such operations before calling this method will raise a
     * NotAvailableException because they require computation of Cholesky
     * decomposition first.
     *
     * @throws NotReadyException   Exception thrown if attempting to call this
     *                             method when this instance is not ready (i.e. no input matrix has been
     *                             provided).
     * @throws LockedException     Exception thrown if this decomposer is already
     *                             locked before calling this method. Notice that this method will actually
     *                             lock this instance while it is being executed.
     * @throws DecomposerException Exception thrown if for any reason
     *                             decomposition fails while being executed, like when convergence of
     *                             results cannot be obtained, etc.
     */
    @Override
    public void decompose() throws NotReadyException, LockedException,
            DecomposerException {

<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L134">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L138">            throw new NotReadyException();</span>
        }

<span class="fc" id="L141">        final int rows = inputMatrix.getRows();</span>
<span class="fc" id="L142">        final int columns = inputMatrix.getColumns();</span>

<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (rows != columns) {</span>
<span class="fc" id="L145">            throw new DecomposerException();</span>
        }

<span class="fc" id="L148">        locked = true;</span>

        final Matrix localR;
        try {
<span class="fc" id="L152">            localR = new Matrix(columns, columns);</span>
<span class="nc" id="L153">        } catch (WrongSizeException e) {</span>
<span class="nc" id="L154">            throw new DecomposerException(e);</span>
<span class="fc" id="L155">        }</span>

<span class="fc" id="L157">        boolean localSpd = true;</span>
        double d;
        double s;

        // Main loop
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (int j = 0; j &lt; columns; j++) {</span>
<span class="fc" id="L163">            d = 0.0;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            for (int k = 0; k &lt; j; k++) {</span>
<span class="fc" id="L165">                s = inputMatrix.getElementAt(k, j);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                for (int i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L167">                    s = s - localR.getElementAt(i, k) *</span>
<span class="fc" id="L168">                            localR.getElementAt(i, j);</span>
                }
<span class="fc" id="L170">                s /= localR.getElementAt(k, k);</span>
<span class="fc" id="L171">                localR.setElementAt(k, j, s);</span>
<span class="fc" id="L172">                d += s * s;</span>
<span class="fc" id="L173">                localSpd &amp;= inputMatrix.getElementAt(k, j) ==</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                        inputMatrix.getElementAt(j, k);</span>
            }
<span class="fc" id="L176">            d = inputMatrix.getElementAt(j, j) - d;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            localSpd &amp;= d &gt; 0.0;</span>
            // sqrt of max(d, 0.0)
<span class="fc" id="L179">            localR.setElementAt(j, j, Math.sqrt(Math.max(d, 0.0)));</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">            for (int k = j + 1; k &lt; columns; k++) {</span>
<span class="fc" id="L181">                localR.setElementAt(k, j, 0.0);</span>
            }
        }

<span class="fc" id="L185">        this.spd = localSpd;</span>
<span class="fc" id="L186">        this.r = localR;</span>

<span class="fc" id="L188">        locked = false;</span>
<span class="fc" id="L189">    }</span>

    /**
     * Returns Cholesky matrix factor corresponding to a Lower triangular matrix
     * following this expression: A = L * L'. Where A is provided input matrix
     * that has been decomposed and L is the left lower triangular matrix
     * factor.
     *
     * @return Returns Cholesky Lower triangular matrix
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before actually computing Cholesky decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     */
    public Matrix getL() throws NotAvailableException {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L205">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L208">        return r.transposeAndReturnNew();</span>
    }

    /**
     * Returns Cholesky matrix factor corresponding to an upper triangular
     * matrix following this expression: A = R' * R. Where A is provided input
     * matrix that has been decomposed and R is the right upper triangular
     * matrix factor.
     *
     * @return Returns Cholesky upper triangular matrix
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before actually computing Cholesky decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     */
    public Matrix getR() throws NotAvailableException {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L225">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L228">        return r;</span>
    }

    /**
     * Returns boolean indicating whether provided input matrix is
     * Symmetric Positive Definite or not.
     * Notice that if returned value is false, then Cholesky decomposition
     * should be ignored, as Cholesky decomposition can only be computed on
     * symmetric positive definite matrices.
     *
     * @return Boolean indicating whether provided input matrix is symmetric
     * positive definite or not.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing Cholesky decomposition. To avoid this exception
     *                               call decompose() method first.
     * @see #decompose()
     */
    public boolean isSPD() throws NotAvailableException {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L247">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L250">        return spd;</span>
    }

    /**
     * Solves a linear system of equations of the following form: A * X = B.
     * Where A is the input matrix provided for Cholesky decomposition, X is the
     * solution to the system of equations, and B is the parameters
     * vector/matrix.
     * Note: This method can be reused for different b vectors/matrices without
     * having to recompute Cholesky decomposition on the same input matrix.
     * Note: Provided b matrix must have the same number of rows as provided
     * input matrix A, otherwise an IllegalArgumentException will be raised
     * Note: Provided input matrix A must be square, otherwise a
     * WrongSizeException will be raised.
     * Note: If provided input matrix A is not symmetric positive definite, a
     * NonSymmetricPositiveDefiniteMatrixException will be thrown.
     * Note: In order to be able to execute this method, a Cholesky
     * decomposition must be available, otherwise a NotAvailableException will
     * be raised. In order to avoid this exception call decompose() method first
     * Note: result matrix contains solution of linear system of equations. It
     * will be resized if provided matrix does not have proper size
     *
     * @param b      Parameters of linear system of equations
     * @param result instance where solution X will be stored.
     * @throws com.irurueta.algebra.NotAvailableException                       if decomposition has
     *                                                                          not yet been computed.
     * @throws com.irurueta.algebra.WrongSizeException                          if the number of rows of
     *                                                                          b matrix is not equal to the number of rows of input matrix provided to
     *                                                                          Cholesky decomposer.
     * @throws com.irurueta.algebra.NonSymmetricPositiveDefiniteMatrixException if input matrix provided to Cholesky decomposer is not positive definite.
     */
    public void solve(final Matrix b, final Matrix result) throws NotAvailableException,
            WrongSizeException, NonSymmetricPositiveDefiniteMatrixException {

<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L285">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L288">        final int rows = inputMatrix.getRows();</span>
<span class="fc" id="L289">        final int columns = inputMatrix.getColumns();</span>
<span class="fc" id="L290">        final int rowsB = b.getRows();</span>
<span class="fc" id="L291">        final int colsB = b.getColumns();</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (rowsB != rows) {</span>
<span class="fc" id="L294">            throw new WrongSizeException();</span>
        }

<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (!isSPD()) {</span>
<span class="fc" id="L298">            throw new NonSymmetricPositiveDefiniteMatrixException();</span>
        }

        // resize result matrix if needed
<span class="pc bpc" id="L302" title="2 of 4 branches missed.">        if (result.getRows() != rowsB || result.getColumns() != colsB) {</span>
<span class="nc" id="L303">            result.resize(rowsB, colsB);</span>
        }

        // Copy b into result matrix
<span class="fc" id="L307">        result.copyFrom(b);</span>

<span class="fc" id="L309">        final Matrix l = getL();</span>

        // Solve L * Y = B
<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (int k = 0; k &lt; columns; k++) {</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            for (int j = 0; j &lt; colsB; j++) {</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">                for (int i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L315">                    result.setElementAt(k, j, result.getElementAt(k, j) -</span>
<span class="fc" id="L316">                            result.getElementAt(i, j) * l.getElementAt(k, i));</span>
                }
<span class="fc" id="L318">                result.setElementAt(k, j,</span>
<span class="fc" id="L319">                        result.getElementAt(k, j) / l.getElementAt(k, k));</span>
            }
        }

        // Solve L' * X = Y
        int k2;
<span class="fc bfc" id="L325" title="All 2 branches covered.">        for (int k = columns - 1; k &gt;= 0; k--) {</span>
<span class="fc" id="L326">            k2 = k;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">            for (int j = 0; j &lt; colsB; j++) {</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">                for (int i = k2 + 1; i &lt; columns; i++) {</span>
<span class="fc" id="L329">                    result.setElementAt(k2, j, result.getElementAt(k2, j) -</span>
<span class="fc" id="L330">                            result.getElementAt(i, j) * l.getElementAt(i, k2));</span>
                }
<span class="fc" id="L332">                result.setElementAt(k2, j,</span>
<span class="fc" id="L333">                        result.getElementAt(k2, j) / l.getElementAt(k2, k2));</span>
            }
        }
<span class="fc" id="L336">    }</span>

    /**
     * Solves a linear system of equations of the following form: A * X = B.
     * Where A is the input matrix provided for Cholesky decomposition, X is the
     * solution to the system of equations, and B is the parameters
     * vector/matrix.
     * Note: This method can be reused for different b vectors/matrices without
     * having to recompute Cholesky decomposition on the same input matrix.
     * Note: Provided b matrix must have the same number of rows as provided
     * input matrix A, otherwise an IllegalArgumentException will be raised
     * Note: Provided input matrix A must be square, otherwise a
     * WrongSizeException will be raised.
     * Note: If provided input matrix A is not symmetric positive definite, a
     * NonSymmetricPositiveDefiniteMatrixException will be thrown.
     * Note: In order to be able to execute this method, a Cholesky
     * decomposition must be available, otherwise a NotAvailableException will
     * be raised. In order to avoid this exception call decompose() method first
     *
     * @param b Parameters of linear system of equations
     * @return a new matrix containing solution X.
     * @throws com.irurueta.algebra.NotAvailableException                       if decomposition has
     *                                                                          not yet been computed.
     * @throws com.irurueta.algebra.WrongSizeException                          if the number of rows of
     *                                                                          b matrix is not equal to the number of rows of input matrix provided to
     *                                                                          Cholesky decomposer.
     * @throws com.irurueta.algebra.NonSymmetricPositiveDefiniteMatrixException if input matrix provided to Cholesky decomposer is not positive definite.
     */
    public Matrix solve(final Matrix b) throws NotAvailableException,
            WrongSizeException, NonSymmetricPositiveDefiniteMatrixException {

<span class="fc" id="L367">        final int columns = inputMatrix.getColumns();</span>
<span class="fc" id="L368">        final int colsB = b.getColumns();</span>
<span class="fc" id="L369">        final Matrix out = new Matrix(columns, colsB);</span>
<span class="fc" id="L370">        solve(b, out);</span>
<span class="fc" id="L371">        return out;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>