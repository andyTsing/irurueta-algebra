<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MultivariateNormalDist.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-algebra</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.statistics</a> &gt; <span class="el_source">MultivariateNormalDist.java</span></div><h1>MultivariateNormalDist.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.statistics;

import com.irurueta.algebra.*;

import java.util.Arrays;

/**
 * Contains methods to work with multivariate normal (i.e. Gaussian)
 * distributions.
 */
public class MultivariateNormalDist {

    /**
     * Mean value of Gaussian distribution.
     */
    private double[] mMu;

    /**
     * Covariance of Gaussian distribution.
     */
    private Matrix mCov;

    /**
     * Basis in which the covariance matrix is expressed.
     * This value is obtained after decomposition.
     */
    private Matrix mCovBasis;

    /**
     * Variances on each direction of the basis.
     */
    private double[] mVariances;

    /**
     * Constructor.
     * Creates a normal distribution of 1 dimension.
     */
    public MultivariateNormalDist() {
<span class="fc" id="L54">        this(1);</span>
<span class="fc" id="L55">    }</span>

    /**
     * Constructor.
     * Creates a multivariate normal distribution having the provided
     * number of dimensions, with zero mean and unitary independent variances.
     *
     * @param dims number of dimensions. Must be greater than zero.
     * @throws IllegalArgumentException if provided number of dimensions is
     *                                  zero or less.
     */
<span class="fc" id="L66">    public MultivariateNormalDist(final int dims) {</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        if (dims &lt;= 0) {</span>
<span class="fc" id="L68">            throw new IllegalArgumentException(</span>
                    &quot;number of dimensions must be greater than zero&quot;);
        }

<span class="fc" id="L72">        mMu = new double[dims];</span>
        try {
<span class="fc" id="L74">            mCov = Matrix.identity(dims, dims);</span>
<span class="nc" id="L75">        } catch (final WrongSizeException e) {</span>
<span class="nc" id="L76">            throw new IllegalArgumentException(</span>
                    &quot;number of dimensions must be greater than zero&quot;, e);
<span class="fc" id="L78">        }</span>
<span class="fc" id="L79">    }</span>

    /**
     * Constructor.
     * Creates a multivariate normal distribution having provided mean and
     * covariance.
     *
     * @param mean       array containing mean. Must have the same number of rows as
     *                   provided covariance matrix
     * @param covariance matrix containing covariance. Must be square, symmetric
     *                   and positive definite (i.e. non singular) and must have the same number
     *                   of rows as provided mean.
     * @throws IllegalArgumentException         if provided mean array has length
     *                                          smaller than 1 or if length of mean array is not the same as the number
     *                                          of rows of covariance matrix.
     * @throws InvalidCovarianceMatrixException if provided covariance matrix is
     *                                          not square, symmetric and positive definite (i.e. non singular).
     */
    public MultivariateNormalDist(final double[] mean, final Matrix covariance)
<span class="fc" id="L98">            throws InvalidCovarianceMatrixException {</span>
<span class="fc" id="L99">        setMeanAndCovariance(mean, covariance);</span>
<span class="fc" id="L100">    }</span>

    /**
     * Constructor.
     * Creates a multivariate normal distribution having provided mean and
     * covariance.
     *
     * @param mean                              array containing mean. Must have the same number of rows as
     *                                          provided covariance matrix.
     * @param covariance                        matrix containing covariance. Must be square, symmetric
     *                                          and positive definite (i.e. non singular) and must have the same number
     *                                          of rows as provided mean.
     * @param validateSymmetricPositiveDefinite true if covariance matrix must
     *                                          be validated to be positive definite, false to skip validation.
     * @throws IllegalArgumentException         if provided mean array has length
     *                                          smaller than 1 or if length of mean array is not the same as the number
     *                                          of rows of covariance matrix.
     * @throws InvalidCovarianceMatrixException if provided matrix is not
     *                                          valid (nor square or symmetric positive definite if validation is
     *                                          enabled).
     */
    public MultivariateNormalDist(final double[] mean, final Matrix covariance,
                                  final boolean validateSymmetricPositiveDefinite)
<span class="fc" id="L123">            throws InvalidCovarianceMatrixException {</span>
<span class="fc" id="L124">        setMeanAndCovariance(mean, covariance,</span>
                validateSymmetricPositiveDefinite);
<span class="fc" id="L126">    }</span>

    /**
     * Gets array containing mean of this multivariate Gaussian distribution.
     *
     * @return mean of multivariate Gaussian distribution.
     */
    public double[] getMean() {
<span class="fc" id="L134">        return mMu;</span>
    }

    /**
     * Sets mean of this multivariate Gaussian distribution.
     * Length of provided mean must be equal to the number of rows of provided
     * covariance, otherwise instance won't be ready.
     *
     * @param mu mean of multivariate Gaussian distribution.
     * @throws IllegalArgumentException if provided array has a length smaller
     *                                  than 1.
     */
    public void setMean(final double[] mu) {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (mu.length == 0) {</span>
<span class="fc" id="L148">            throw new IllegalArgumentException(</span>
                    &quot;length of mean array must be greater than zero&quot;);
        }
<span class="fc" id="L151">        mMu = mu;</span>
<span class="fc" id="L152">    }</span>

    /**
     * Gets matrix containing covariance of this multivariate Gaussian
     * distribution.
     *
     * @return covariance of multivariate Gaussian distribution.
     */
    public Matrix getCovariance() {
<span class="fc" id="L161">        return new Matrix(mCov);</span>
    }

    /**
     * Gets matrix containing covariance of this multivariate Gaussian
     * distribution.
     *
     * @param result instance where covariance of multivariate Gaussian
     *               distribution will be stored.
     */
    public void getCovariance(final Matrix result) {
<span class="fc" id="L172">        mCov.copyTo(result);</span>
<span class="fc" id="L173">    }</span>

    /**
     * Sets covariance of this multivariate Gaussian distribution.
     *
     * @param cov covariance of this multivariate Gaussian distribution.
     * @throws InvalidCovarianceMatrixException if provided matrix is not valid
     *                                          (not square or symmetric positive definite).
     */
    public void setCovariance(final Matrix cov)
            throws InvalidCovarianceMatrixException {
<span class="fc" id="L184">        setCovariance(cov, true);</span>
<span class="fc" id="L185">    }</span>

    /**
     * Sets covariance of this multivariate Gaussian distribution.
     *
     * @param cov                               covariance of this multivariate Gaussian distribution.
     * @param validateSymmetricPositiveDefinite true if matrix must be
     *                                          validated to be positive definite, false to skip validation.
     * @throws InvalidCovarianceMatrixException if provided matrix is not
     *                                          valid (nor square or symmetric positive definite if validation is
     *                                          enabled).
     */
    public void setCovariance(final Matrix cov,
                              final boolean validateSymmetricPositiveDefinite)
            throws InvalidCovarianceMatrixException {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (cov.getRows() != cov.getColumns()) {</span>
<span class="fc" id="L201">            throw new InvalidCovarianceMatrixException(</span>
                    &quot;covariance matrix must be square&quot;);
        }

        try {
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (validateSymmetricPositiveDefinite) {</span>
<span class="fc" id="L207">                final CholeskyDecomposer decomposer = new CholeskyDecomposer(cov);</span>
<span class="fc" id="L208">                decomposer.decompose();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">                if (!decomposer.isSPD()) {</span>
<span class="fc" id="L210">                    throw new InvalidCovarianceMatrixException(</span>
                            &quot;covariance matrix must be symmetric positive &quot; +
                                    &quot;definite (non singular)&quot;);
                }
            }

<span class="fc" id="L216">            mCov = new Matrix(cov);</span>
<span class="fc" id="L217">            mCovBasis = null;</span>
<span class="fc" id="L218">            mVariances = null;</span>
<span class="nc" id="L219">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L220">            throw new InvalidCovarianceMatrixException(</span>
                    &quot;covariance matrix must be square&quot;, e);
<span class="fc" id="L222">        }</span>
<span class="fc" id="L223">    }</span>

    /**
     * Sets mean and covariance of this multivariate Gaussian distribution.
     *
     * @param mu  array containing mean. Must have the same number of rows as
     *            provided covariance matrix
     * @param cov matrix containing covariance. Must be square, symmetric
     *            and positive definite (i.e. non singular) and must have the same number
     *            of rows as provided mean.
     * @throws IllegalArgumentException         if provided mean array has length
     *                                          smaller than 1 or if length of mean array is not the same as the number
     *                                          of rows of covariance matrix.
     * @throws InvalidCovarianceMatrixException if provided covariance matrix is
     *                                          not square, symmetric and positive definite (i.e. non singular).
     */
    public final void setMeanAndCovariance(final double[] mu, final Matrix cov)
            throws InvalidCovarianceMatrixException {
<span class="fc" id="L241">        setMeanAndCovariance(mu, cov, true);</span>
<span class="fc" id="L242">    }</span>

    /**
     * Sets mean and covariance of this multivariate Gaussian distribution.
     *
     * @param mu                                array containing mean. Must have the same number of rows as
     *                                          provided covariance matrix
     * @param cov                               matrix containing covariance. Must be square, symmetric
     *                                          and positive definite (i.e. non singular) and must have the same number
     *                                          of rows as provided mean.
     * @param validateSymmetricPositiveDefinite true if matrix must be
     *                                          validated to be positive definite, false to skip validation.
     * @throws IllegalArgumentException         if provided mean array has length
     *                                          smaller than 1 or if length of mean array is not the same as the number
     *                                          of rows of covariance matrix.
     * @throws InvalidCovarianceMatrixException if provided covariance matrix is
     *                                          not square, symmetric and positive definite (i.e. non singular).
     */
    public final void setMeanAndCovariance(final double[] mu, final Matrix cov,
                                           final boolean validateSymmetricPositiveDefinite)
            throws InvalidCovarianceMatrixException {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (mu.length != cov.getRows()) {</span>
<span class="fc" id="L264">            throw new IllegalArgumentException(&quot;mean array length must be &quot; +</span>
                    &quot;equal to covariance number of rows&quot;);
        }

<span class="fc" id="L268">        setCovariance(cov, validateSymmetricPositiveDefinite);</span>
<span class="fc" id="L269">        setMean(mu);</span>
<span class="fc" id="L270">    }</span>

    /**
     * Indicates whether provided matrix is a valid covariance matrix.
     * A valid covariance matrix must be square, symmetric and positive definite
     * (i.e. non-singular).
     *
     * @param cov matrix to be checked.
     * @return true if matrix is a valid covariance matrix, false otherwise.
     */
    public static boolean isValidCovariance(final Matrix cov) {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (cov.getRows() != cov.getColumns()) {</span>
<span class="fc" id="L282">            return false;</span>
        }

        try {
<span class="fc" id="L286">            final CholeskyDecomposer decomposer = new CholeskyDecomposer(cov);</span>
<span class="fc" id="L287">            decomposer.decompose();</span>
<span class="fc" id="L288">            return decomposer.isSPD();</span>
<span class="nc" id="L289">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L290">            return false;</span>
        }
    }

    /**
     * Indicates whether this instance is ready for any computation, false
     * otherwise.
     *
     * @return true if instance is ready, false otherwise.
     */
    public boolean isReady() {
<span class="pc bpc" id="L301" title="2 of 4 branches missed.">        return mMu != null &amp;&amp; mCov != null &amp;&amp;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">                mMu.length == mCov.getRows();</span>
    }

    /**
     * Basis containing on each column the direction of each variance in the
     * multidimensional Gaussian distribution, which is obtained from provided
     * covariance matrix.
     * This value is available only after the p.d.f. has been evaluated.
     *
     * @return basis containing on each column the direction of each variance
     * in the multidimensional Gaussian distribution.
     */
    public Matrix getCovarianceBasis() {
<span class="fc" id="L315">        return mCovBasis;</span>
    }

    /**
     * Array containing the amount of variance on each direction of the basis
     * of the covariance in the multidimensional Gaussian distribution.
     * This value is available only after the p.d.f. has been evaluated.
     *
     * @return variance on each direction of the basis of the covariance.
     */
    public double[] getVariances() {
<span class="fc" id="L326">        return mVariances;</span>
    }

    /**
     * Evaluates the probability density function (p.d.f.) of a multivariate
     * Gaussian distribution having current mean and covariance at point x.
     *
     * @param x array containing coordinates where p.d.f. is evaluated.
     * @return evaluation of p.d.f.
     * @throws NotReadyException            if this instance is not ready (mean and
     *                                      covariance have not been provided or are not valid).
     * @throws IllegalArgumentException     if provided point length is not valid.
     * @throws DecomposerException          happens if covariance is numerically
     *                                      unstable (i.e. contains NaNs or very large numbers).
     * @throws RankDeficientMatrixException happens if covariance is singular.
     */
    public double p(final double[] x) throws NotReadyException,
            DecomposerException, RankDeficientMatrixException {
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L345">            throw new NotReadyException();</span>
        }

<span class="fc" id="L348">        final int k = x.length;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (k != mMu.length) {</span>
<span class="fc" id="L350">            throw new IllegalArgumentException(</span>
                    &quot;length of point must be equal to the length of mean&quot;);
        }

<span class="fc" id="L354">        double detCov = 0.0;</span>
        try {
<span class="fc" id="L356">            detCov = Utils.det(mCov);</span>
<span class="nc" id="L357">        } catch (final WrongSizeException ignore) {</span>
            // never thrown
<span class="fc" id="L359">        }</span>

<span class="fc" id="L361">        final double factor = 1.0 / (Math.sqrt(Math.pow(2.0 * Math.PI, k) *</span>
                detCov));
<span class="fc" id="L363">        return factor * Math.exp(-0.5 * squaredMahalanobisDistance(x));</span>
    }

    /**
     * Evaluates the cumulative distribution function (c.d.f.) of a Gaussian
     * distribution having current mean and covariance values.
     * The c.d.f. is equivalent to the joint probability of the multivariate
     * Gaussian distribution of having a value less than x on each direction
     * of the basis of independent variances obtained from covariance matrix.
     * Because the c.d.f is a probability, it always returns values between 0.0
     * and 1.0.
     * NOTE: this method will resize provided basis instance if needed.
     *
     * @param x     point where c.d.f. is evaluated.
     * @param basis instance where is stored the basis of each direction of
     *              independent covariances, if provided.
     * @return evaluation of c.d.f.
     * @throws IllegalArgumentException if length of provided point is not equal
     *                                  to length of current mean.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      if covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public double cdf(final double[] x, final Matrix basis) throws NotReadyException,
            DecomposerException {
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L390">            throw new NotReadyException();</span>
        }

<span class="fc" id="L393">        final int k = x.length;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (k != mMu.length) {</span>
<span class="fc" id="L395">            throw new IllegalArgumentException(</span>
                    &quot;length of point must be equal to the length of mean&quot;);
        }

<span class="fc" id="L399">        double p = 1.0;</span>
        try {
<span class="fc" id="L401">            processCovariance();</span>

<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (basis != null) {</span>
<span class="fc" id="L404">                basis.copyFrom(mCovBasis);</span>
            }

<span class="fc bfc" id="L407" title="All 2 branches covered.">            for (int i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L408">                final double[] singleBasis =</span>
<span class="fc" id="L409">                        mCovBasis.getSubmatrixAsArray(0, i, k - 1, i);</span>
<span class="fc" id="L410">                final double coordX = ArrayUtils.dotProduct(x, singleBasis);</span>
<span class="fc" id="L411">                final double coordMu = ArrayUtils.dotProduct(mMu, singleBasis);</span>
<span class="fc" id="L412">                p *= NormalDist.cdf(coordX, coordMu, Math.sqrt(mVariances[i]));</span>
            }

<span class="nc" id="L415">        } catch (final DecomposerException e) {</span>
<span class="nc" id="L416">            throw e;</span>
<span class="nc" id="L417">        } catch (final AlgebraException ignore) {</span>
            // never thrown
<span class="fc" id="L419">        }</span>

<span class="fc" id="L421">        return p;</span>
    }

    /**
     * Evaluates the cumulative distribution function (c.d.f.) of a Gaussian
     * distribution having current mean and covariance values.
     * The c.d.f. is equivalent to the joint probability of the multivariate
     * Gaussian distribution of having a value less than x on each direction
     * of the basis of independent variances obtained from covariance matrix.
     * Because the c.d.f is a probability, it always returns values between 0.0
     * and 1.0.
     *
     * @param x point where c.d.f. is evaluated.
     * @return evaluation of c.d.f.
     * @throws IllegalArgumentException if length of provided point is not equal
     *                                  to length of current mean.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      if covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public double cdf(double[] x) throws NotReadyException, DecomposerException {
<span class="fc" id="L443">        return cdf(x, null);</span>
    }

    /**
     * Computes the joint probability of all probabilities provided in the
     * array. The joint probability is computed by multiplying all components of
     * the array, assuming that all probabilities are independent.
     *
     * @param p array containing probabilities for each independent variance
     *          direction that can be obtained from provided covariance matrix.
     * @return joint probability.
     */
    public static double jointProbability(final double[] p) {
<span class="fc" id="L456">        double jointP = 1.0;</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (final double aP : p) {</span>
<span class="fc" id="L458">            jointP *= aP;</span>
        }
<span class="fc" id="L460">        return jointP;</span>
    }

    /**
     * Evaluates the inverse cumulative distribution function of a multivariate
     * Gaussian distribution for current mean and covariance values and provided
     * probability values for each dimension of the multivariate Gaussian
     * distribution.
     * NOTE: this method will resize provided basis instance if needed.
     *
     * @param p      array containing probability values to evaluate the inverse
     *               c.d.f. on each dimension. Values in the array must be between 0.0 and
     *               1.0.
     * @param result coordinates of the value x for which the c.d.f. has values
     *               p.
     * @param basis  instance where is stored the basis of each direction of
     *               independent covariances, if provided.
     * @throws IllegalArgumentException if length of probabilities is not equal
     *                                  to mean length, or if result and length of probabilities are not equal,
     *                                  or if provided probabilities are not between 0.0 and 1.0.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      if covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public void invcdf(final double[] p, final double[] result, final Matrix basis)
            throws NotReadyException, DecomposerException {
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L488">            throw new NotReadyException(</span>
                    &quot;mean and covariance not provided or invalid&quot;);
        }

<span class="fc" id="L492">        final int k = p.length;</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (k != mMu.length) {</span>
<span class="fc" id="L494">            throw new IllegalArgumentException(</span>
                    &quot;length of probabilities must be equal to the length of &quot;
                            + &quot;mean&quot;);
        }
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (k != result.length) {</span>
<span class="fc" id="L499">            throw new IllegalArgumentException(&quot;length of result must be equal &quot;</span>
                    + &quot;to the length of mean&quot;);
        }

        try {
<span class="fc" id="L504">            processCovariance();</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">            if (basis != null) {</span>
<span class="fc" id="L507">                basis.copyFrom(mCovBasis);</span>
            }

            // initialize to mean
<span class="fc" id="L511">            System.arraycopy(mMu, 0, result, 0, k);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">            for (int i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L513">                final double[] singleBasis =</span>
<span class="fc" id="L514">                        mCovBasis.getSubmatrixAsArray(0, i, k - 1, i);</span>
<span class="fc" id="L515">                final double coord = NormalDist.invcdf(p[i], mMu[i],</span>
<span class="fc" id="L516">                        Math.sqrt(mVariances[i])) - mMu[i];</span>
                // coord*singleBasis
<span class="fc" id="L518">                ArrayUtils.multiplyByScalar(singleBasis, coord, singleBasis);</span>

                // result = mean + coord*singleBasis
<span class="fc" id="L521">                ArrayUtils.sum(result, singleBasis, result);</span>
            }
<span class="nc" id="L523">        } catch (final DecomposerException e) {</span>
<span class="nc" id="L524">            throw e;</span>
<span class="nc" id="L525">        } catch (final AlgebraException ignore) {</span>
            // never thrown
<span class="fc" id="L527">        }</span>
<span class="fc" id="L528">    }</span>

    /**
     * Evaluates the inverse cumulative distribution function of a multivariate
     * Gaussian distribution for current mean and covariance values and provided
     * probability values for each dimension of the multivariate Gaussian
     * distribution.
     * NOTE: this method will resize provided basis instance if needed.
     *
     * @param p     array containing probability values to evaluate the inverse
     *              c.d.f. on each dimension. Values in the array must be between 0.0 and
     *              1.0.
     * @param basis instance where is stored the basis of each direction of
     *              independent covariances, if provided.
     * @return a new array containing coordinates of the value x for which the
     * c.d.f. has values p.
     * @throws IllegalArgumentException if length of probabilities is not equal
     *                                  to mean length, or if provided probabilities are not between 0.0 and 1.0.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      if covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public double[] invcdf(final double[] p, final Matrix basis)
            throws NotReadyException, DecomposerException {
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (mMu == null) {</span>
<span class="nc" id="L554">            throw new NotReadyException(&quot;mean not defined&quot;);</span>
        }

<span class="fc" id="L557">        final double[] result = new double[mMu.length];</span>
<span class="fc" id="L558">        invcdf(p, result, basis);</span>
<span class="fc" id="L559">        return result;</span>
    }

    /**
     * Evaluates the inverse cumulative distribution function of a multivariate
     * Gaussian distribution for current mean and covariance values and provided
     * probability values for each dimension of the multivariate Gaussian
     * distribution.
     *
     * @param p      array containing probability values to evaluate the inverse
     *               c.d.f. on each dimension. Values in the array must be between 0.0 and
     *               1.0.
     * @param result coordinates of the value x for which the c.d.f. has values
     *               p.
     * @throws IllegalArgumentException if length of probabilities is not equal
     *                                  to mean length, or if result and length of probabilities are not equal,
     *                                  or if provided probabilities are not between 0.0 and 1.0.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      if covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public void invcdf(final double[] p, final double[] result)
            throws NotReadyException, DecomposerException {
<span class="fc" id="L583">        invcdf(p, result, null);</span>
<span class="fc" id="L584">    }</span>

    /**
     * Evaluates the inverse cumulative distribution function of a multivariate
     * Gaussian distribution for current mean and covariance values and provided
     * probability values for each dimension of the multivariate Gaussian
     * distribution.
     *
     * @param p array containing probability values to evaluate the inverse
     *          c.d.f. on each dimension. Values in the array must be between 0.0 and
     *          1.0.
     * @return coordinates of the value x for which the c.d.f. has values
     * * p.
     * @throws IllegalArgumentException if length of probabilities is not equal
     *                                  to mean length, or if result and length of probabilities are not equal,
     *                                  or if provided probabilities are not between 0.0 and 1.0.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      if covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public double[] invcdf(final double[] p) throws NotReadyException, DecomposerException {
<span class="fc" id="L606">        return invcdf(p, (Matrix) null);</span>
    }

    /**
     * Evaluates the inverse cumulative distribution function of a multivariate
     * Gaussian distribution for current mean and covariance values and provided
     * probability value.
     * Obtained result coordinates are computed taking into account the basis
     * of independent variances computed from current covariance matrix.
     * NOTE: notice that the inverse cdf of a mutivariate Gaussian distribution
     * does not have a unique solution. This method simply returns one of the
     * possible solutions by assuming equal probabilities on each dimension.
     * NOTE: this method will resize provided basis instance if needed.
     *
     * @param p      probability value to evaluate the inverse c.d.f. at. This value
     *               must be between 0.0 and 1.0
     * @param result coordinates of the value x for which the c.d.f. has value
     *               p.
     * @param basis  instance where is stored the basis of each direction of
     *               independent covariances, if provided.
     * @throws IllegalArgumentException if provided probability value is not
     *                                  between 0.0 and 1.0, if length of provided result array is not equal
     *                                  to length of current mean.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      if covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public void invcdf(final double p, final double[] result, final Matrix basis)
            throws NotReadyException, DecomposerException {
<span class="fc bfc" id="L636" title="All 4 branches covered.">        if (p &lt;= 0.0 || p &gt;= 1.0) {</span>
<span class="fc" id="L637">            throw new IllegalArgumentException(</span>
                    &quot;probability value must be between 0.0 and 1.0&quot;);
        }

<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L642">            throw new NotReadyException(</span>
                    &quot;mean and covariance not provided or invalid&quot;);
        }

<span class="fc" id="L646">        final int k = result.length;</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">        if (k != mMu.length) {</span>
<span class="fc" id="L648">            throw new IllegalArgumentException(</span>
                    &quot;length of result must be equal to mean length&quot;);
        }

<span class="fc" id="L652">        final double[] probs = new double[k];</span>
<span class="fc" id="L653">        Arrays.fill(probs, Math.pow(p, 1.0 / k));</span>
<span class="fc" id="L654">        invcdf(probs, result, basis);</span>
<span class="fc" id="L655">    }</span>

    /**
     * Evaluates the inverse cumulative distribution function of a multivariate
     * Gaussian distribution for current mean and covariance values and provided
     * probability value.
     * Obtained result coordinates are computed taking into account the basis
     * of independent variances computed from current covariance matrix.
     * NOTE: notice that the inverse cdf of a mutivariate Gaussian distribution
     * does not have a unique solution. This method simply returns one of the
     * possible solutions by assuming equal probabilities on each dimension.
     * NOTE: this method will resize provided basis instance if needed.
     *
     * @param p     probability value to evaluate the inverse c.d.f. at. This value
     *              must be between 0.0 and 1.0
     * @param basis instance where is stored the basis of each direction of
     *              independent covariances, if provided.
     * @return a new array containing the coordinates of the value x for which
     * the c.d.f. has value p.
     * @throws IllegalArgumentException if provided probability value is not
     *                                  between 0.0 and 1.0.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      f covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public double[] invcdf(final double p, final Matrix basis)
            throws NotReadyException, DecomposerException {
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">        if (mMu == null) {</span>
<span class="nc" id="L684">            throw new NotReadyException(&quot;mean not defined&quot;);</span>
        }

<span class="fc" id="L687">        final double[] result = new double[mMu.length];</span>
<span class="fc" id="L688">        invcdf(p, result, basis);</span>
<span class="fc" id="L689">        return result;</span>
    }

    /**
     * Evaluates the inverse cumulative distribution function of a multivariate
     * Gaussian distribution for current mean and covariance values and provided
     * probability value.
     * Obtained result coordinates are computed taking into account the basis
     * of independent variances computed from current covariance matrix.
     * NOTE: notice that the inverse cdf of a mutivariate Gaussian distribution
     * does not have a unique solution. This method simply returns one of the
     * possible solutions by assuming equal probabilities on each dimension.
     *
     * @param p      probability value to evaluate the inverse c.d.f. at. This value
     *               must be between 0.0 and 1.0
     * @param result coordinates of the value x for which the c.d.f. has value
     *               p.
     * @throws IllegalArgumentException if provided probability value is not
     *                                  between 0.0 and 1.0, if length of provided result array is not equal
     *                                  to length of current mean.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      f covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public void invcdf(final double p, final double[] result)
            throws NotReadyException, DecomposerException {
<span class="fc" id="L716">        invcdf(p, result, null);</span>
<span class="fc" id="L717">    }</span>

    /**
     * Evaluates the inverse cumulative distribution function of a multivariate
     * Gaussian distribution for current mean and covariance values and provided
     * probability value.
     * Obtained result coordinates are computed taking into account the basis
     * of independent variances computed from current covariance matrix.
     * NOTE: notice that the inverse cdf of a mutivariate Gaussian distribution
     * does not have a unique solution. This method simply returns one of the
     * possible solutions by assuming equal probabilities on each dimension.
     *
     * @param p probability value to evaluate the inverse c.d.f. at. This value
     *          must be between 0.0 and 1.0
     * @return a new array containing the coordinates of the value x for which
     * the c.d.f. has value p.
     * @throws IllegalArgumentException if provided probability value is not
     *                                  between 0.0 and 1.0.
     * @throws NotReadyException        if this instance is not ready (mean and
     *                                  covariance have not been provided or are not valid).
     * @throws DecomposerException      f covariance is numerically unstable (i.e.
     *                                  contains NaNs or very large numbers).
     */
    public double[] invcdf(final double p) throws NotReadyException, DecomposerException {
<span class="fc" id="L741">        return invcdf(p, (Matrix) null);</span>
    }

    /**
     * Computes the Mahalanobis distance of provided multivariate pot x for
     * current mean and covariance values.
     *
     * @param x point where Mahalanobis distance is evaluated.
     * @return Mahalanobis distance of provided point respect to mean.
     * @throws DecomposerException          happens if covariance is numerically
     *                                      unstable (i.e. contains NaNs or very large numbers).
     * @throws RankDeficientMatrixException happens if covariance is singular.
     */
    public double mahalanobisDistance(final double[] x) throws DecomposerException,
            RankDeficientMatrixException {
<span class="fc" id="L756">        return Math.sqrt(squaredMahalanobisDistance(x));</span>
    }

    /**
     * Computes the squared Mahalanobis distance of provided multivariate pot x
     * for current mean and covariance values.
     *
     * @param x point where Mahalanobis distance is evaluated.
     * @return Mahalanobis distance of provided point respect to mean.
     * @throws DecomposerException          happens if covariance is numerically
     *                                      unstable (i.e. contains NaNs or very large numbers).
     * @throws RankDeficientMatrixException happens if covariance is singular.
     */
    public double squaredMahalanobisDistance(final double[] x) throws DecomposerException,
            RankDeficientMatrixException {
<span class="fc" id="L771">        final double[] diff = ArrayUtils.subtractAndReturnNew(x, mMu);</span>
<span class="fc" id="L772">        final Matrix diffMatrix = Matrix.newFromArray(diff, true);</span>
<span class="fc" id="L773">        final Matrix transDiffMatrix = diffMatrix.transposeAndReturnNew();</span>

        try {
<span class="fc" id="L776">            final Matrix invCov = Utils.inverse(mCov);</span>
<span class="fc" id="L777">            transDiffMatrix.multiply(invCov);</span>
<span class="fc" id="L778">            transDiffMatrix.multiply(diffMatrix);</span>

<span class="nc" id="L780">        } catch (final WrongSizeException ignore) {</span>
            // never thrown
<span class="fc" id="L782">        }</span>

<span class="fc" id="L784">        return transDiffMatrix.getElementAtIndex(0);</span>
    }

    /**
     * Processes current covariance by decomposing it into a basis and its
     * corresponding variances if needed.
     *
     * @throws DecomposerException   happens if covariance is numerically
     *                               unstable (i.e. contains NaNs or very large numbers).
     * @throws NotReadyException     never thrown because decomposer will always be
     *                               ready.
     * @throws LockedException       never thrown because decomposer never will be
     *                               locked.
     * @throws NotAvailableException never thrown because first a
     *                               DecomposerException will be thrown before attempting to get V or
     *                               singular values.
     */
    public void processCovariance() throws DecomposerException,
            NotReadyException, LockedException, NotAvailableException {
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">        if (mCov == null) {</span>
<span class="nc" id="L804">            throw new NotReadyException(&quot;covariance must be defined&quot;);</span>
        }

<span class="pc bpc" id="L807" title="1 of 4 branches missed.">        if (mCovBasis == null || mVariances == null) {</span>
<span class="fc" id="L808">            final SingularValueDecomposer decomposer =</span>
                    new SingularValueDecomposer(mCov);
<span class="fc" id="L810">            decomposer.decompose();</span>

            // because matrix is symmetric positive definite:
            // And matrices U and V are orthonormal
            // Cov = A'*A = (U*S*V')'*(U*S*V')=V*S*U'*U*S*V' = V*S^2*V',

            // where matrix S is diagonal, and contains the standard deviations
            // on each direction of the basis V, and hence S^2 is also diagonal but
            // containing variances on each direction.
            // The values of S^2 are the eigenvalues of Cov, and V are the
            // eigenvectors of Cov, hence covariance can be expressed as variances
            // on each direction of the basis V.

            // matrix containing eigenvectors (basis of directions)
<span class="fc" id="L824">            mCovBasis = decomposer.getV();</span>

            // array containing the eigenvalues (variances on each direction)
<span class="fc" id="L827">            mVariances = decomposer.getSingularValues();</span>
        }
<span class="fc" id="L829">    }</span>

    /**
     * Evaluates the Jacobian and a multivariate function at a certain mean
     * point and computes the non-linear propagation of Gaussian uncertainty
     * through such function at such point.
     *
     * @param evaluator  interface to evaluate a multivariate function and its
     *                   Jacobian at a certain point.
     * @param mean       mean of original multivariate Gaussian distribution to be
     *                   propagated. Must have the length of the number of input variables of the
     *                   multivariate function to be evaluated.
     * @param covariance covariance of original Gaussian distribution to be
     *                   propagated. Must be symmetric positive definite having size NxN where N
     *                   is the length of provided mean.
     * @param result     instance where propagated multiavariate Gaussian
     *                   distribution will be stored.
     * @throws WrongSizeException               if evaluator returns an invalid number of
     *                                          variables (i.e. negative or zero).
     * @throws InvalidCovarianceMatrixException if provided covariance matrix is
     *                                          not valid (i.e. is not symmetric positive definite).
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void propagate(final JacobianEvaluator evaluator, final double[] mean,
                                 final Matrix covariance, final MultivariateNormalDist result)
            throws WrongSizeException, InvalidCovarianceMatrixException {

<span class="fc" id="L856">        final int ndims = mean.length;</span>
<span class="fc" id="L857">        final int nvars = evaluator.getNumberOfVariables();</span>
<span class="fc" id="L858">        final double[] evaluation = new double[nvars];</span>
<span class="fc" id="L859">        final Matrix jacobian = new Matrix(nvars, ndims);</span>
<span class="fc" id="L860">        evaluator.evaluate(mean, evaluation, jacobian);</span>

        // [y, Y_x] = f(x)
        // Y = Y_x * X * Y_x'
<span class="fc" id="L864">        final Matrix jacobianTrans = jacobian.transposeAndReturnNew();</span>
<span class="fc" id="L865">        jacobian.multiply(covariance);</span>
<span class="fc" id="L866">        jacobian.multiply(jacobianTrans);</span>

        // ensure that new covariance is symmetric positive definite
<span class="fc" id="L869">        jacobian.symmetrize();</span>

<span class="fc" id="L871">        result.setMean(evaluation);</span>
<span class="fc" id="L872">        result.setCovariance(jacobian, false);</span>
<span class="fc" id="L873">    }</span>

    /**
     * Evaluates the Jacobian and a multivariate function at a certain mean
     * point and computes the non-linear propagation of Gaussian uncertainty
     * through such function at such point.
     *
     * @param evaluator  interface to evaluate a multivariate function and its
     *                   Jacobian at a certain point.
     * @param mean       mean of original multivariate Gaussian distribution to be
     *                   propagated. Must have the length of the number of input variables of the
     *                   multivariate function to be evaluated.
     * @param covariance covariance of original Gaussian distribution to be
     *                   propagated. Must be symmetric positive definite having size NxN where N
     *                   is the length of provided mean.
     * @return a new propagated multivariate Gaussian distribution.
     * @throws WrongSizeException               if evaluator returns an invalid number of
     *                                          variables (i.e. negative or zero).
     * @throws InvalidCovarianceMatrixException if provided covariance matrix is
     *                                          not valid (i.e. is not symmetric positive definite).
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static MultivariateNormalDist propagate(
            final JacobianEvaluator evaluator, final double[] mean, final Matrix covariance)
            throws WrongSizeException, InvalidCovarianceMatrixException {
<span class="fc" id="L898">        final MultivariateNormalDist result = new MultivariateNormalDist();</span>
<span class="fc" id="L899">        propagate(evaluator, mean, covariance, result);</span>
<span class="fc" id="L900">        return result;</span>
    }

    /**
     * Evaluates the Jacobian and a multivariate function at a certain mean
     * point and computes the non-linear propagation of Gaussian uncertainty
     * through such function at such point.
     *
     * @param evaluator interface to evaluate a multivariate function and its
     *                  Jacobian at a certain point.
     * @param dist      multivariate Gaussian distribution to be propagated.
     * @param result    instance where propagated multivariate Gaussian
     *                  distribution will be stored.
     * @throws WrongSizeException if evaluator returns an invalid number of
     *                            variables (i.e. negative or zero).
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void propagate(final JacobianEvaluator evaluator,
                                 final MultivariateNormalDist dist, final MultivariateNormalDist result)
            throws WrongSizeException {
        try {
<span class="fc" id="L921">            propagate(evaluator, dist.getMean(), dist.getCovariance(), result);</span>
<span class="nc" id="L922">        } catch (final InvalidCovarianceMatrixException ignore) {</span>
            // never thrown
<span class="fc" id="L924">        }</span>
<span class="fc" id="L925">    }</span>

    /**
     * Evaluates the Jacobian and a multivariate function at a certain mean
     * point and computes the non-linear propagation of Gaussian uncertainty
     * through such function at such point.
     *
     * @param evaluator interface to evaluate a multivariate function and its
     *                  Jacobian at a certain point.
     * @param dist      multivariate Gaussian distribution to be propagated.
     * @return a new propagated multivariate Gaussian distribution.
     * @throws WrongSizeException if evaluator returns an invalid number of
     *                            variables (i.e. negative or zero).
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static MultivariateNormalDist propagate(
            final JacobianEvaluator evaluator, final MultivariateNormalDist dist)
            throws WrongSizeException {
<span class="fc" id="L943">        final MultivariateNormalDist result = new MultivariateNormalDist();</span>
<span class="fc" id="L944">        propagate(evaluator, dist, result);</span>
<span class="fc" id="L945">        return result;</span>
    }

    /**
     * Evaluates the Jacobian and a multivariate function at the mean point of
     * this distribution and computes the non-linear propagation of Gaussian
     * uncertainty through such function at such point.
     *
     * @param evaluator interface to evaluate a multivariate function and its
     *                  Jacobian at a certain point.
     * @param result    instance where propagated multivariate Gaussian
     *                  distribution will be stored.
     * @throws WrongSizeException if evaluator returns an invalid number of
     *                            variables (i.e. negative or zero).
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void propagateThisDistribution(final JacobianEvaluator evaluator,
                                          final MultivariateNormalDist result) throws WrongSizeException {
<span class="fc" id="L963">        propagate(evaluator, this, result);</span>
<span class="fc" id="L964">    }</span>

    /**
     * Evaluates the Jacobian and a multivariate function at the mean point of
     * this distribution and computes the non-linear propagation of Gaussian
     * uncertainty through such function at such point.
     *
     * @param evaluator interface to evaluate a multivariate function and its
     *                  Jacobian at a certain point.
     * @return a new propagated multivariate Gaussian distribution.
     * @throws WrongSizeException if evaluator returns an invalid number of
     *                            variables (i.e. negative or zero).
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public MultivariateNormalDist propagateThisDistribution(
            final JacobianEvaluator evaluator) throws WrongSizeException {
<span class="fc" id="L980">        final MultivariateNormalDist result = new MultivariateNormalDist();</span>
<span class="fc" id="L981">        propagateThisDistribution(evaluator, result);</span>
<span class="fc" id="L982">        return result;</span>
    }

    /**
     * Interface to evaluate a multivariate function at multivariate point x to
     * obtain multivariate result y and its corresponding jacobian at point x.
     */
    public interface JacobianEvaluator {
        /**
         * Evaluates multivariate point
         *
         * @param x        array containing multivariate point where function is
         *                 evaluated.
         * @param y        result of evaluating multivariate point.
         * @param jacobian jacobian of multivariate function at point x.
         */
        void evaluate(final double[] x, final double[] y, final Matrix jacobian);

        /**
         * Number of variables in output of evaluated function. This is equal
         * to the length of the array y obtained as function evaluations.
         *
         * @return number of variables of the function.
         */
        int getNumberOfVariables();
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>